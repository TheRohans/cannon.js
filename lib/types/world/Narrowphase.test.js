import { World } from './World';
import { Narrowphase } from './Narrowphase';
import { Sphere } from '../shapes/Sphere';
import { Body } from '../objects/Body';
import { ContactMaterial } from '../material/ContactMaterial';
import { Vec3 } from '../math/Vec3';
import { Quaternion } from '../math/Quaternion';
import { ConvexPolyhedron } from '../shapes/ConvexPolyhedron';
import { mockCube, mockBoxHull } from '../dapao.test';
describe('Narrowphase', function () {
    var cm;
    beforeEach(function () {
        cm = new ContactMaterial();
        cm.friction = 0;
        cm.restitution = 0;
    });
    it('should sphereSphere', function () {
        var world = new World();
        var cg = new Narrowphase(world);
        var result = [];
        var sphereShape = new Sphere(1);
        var bodyA = new Body({ mass: 1 });
        bodyA.addShape(sphereShape);
        var bodyB = new Body({ mass: 1 });
        bodyB.addShape(sphereShape);
        cg.currentContactMaterial = cm;
        cg.result = result;
        cg.sphereSphere(sphereShape, sphereShape, new Vec3(0.5, 0, 0), new Vec3(-0.5, 0, 0), new Quaternion(), new Quaternion(), bodyA, bodyB);
        expect(result.length).toEqual(1);
    });
    it('should return false if convexConvex does not touch (tri)', function () {
        var mc = mockCube();
        var world = new World();
        world.defaultContactMaterial = cm;
        var np = new Narrowphase(world);
        var s1 = new ConvexPolyhedron(mc[0], mc[2]);
        var s2 = new ConvexPolyhedron(mc[0], mc[2]);
        var b1 = new Body({ mass: 1 });
        b1.addShape(s1);
        b1.position = new Vec3(0, 1.5, 0);
        var b2 = new Body({ mass: 1 });
        b2.addShape(s2);
        b2.position = new Vec3(0, -1.5, 0);
        var actual = np.convexConvex(s1, s2, b1.position, b2.position, new Quaternion(), new Quaternion(), b1, b2, undefined, undefined, false);
        expect(actual).toEqual(false);
        expect(np.result.length).toEqual(0);
    });
    it('should return true if convexConvex does touch X (quad)', function () {
        var s1 = mockBoxHull(1);
        var s2 = mockBoxHull(1);
        var world = new World();
        var np = new Narrowphase(world);
        var b1 = new Body({ mass: 1 });
        b1.addShape(s1);
        b1.position = new Vec3(0.5, 0, 0);
        var b2 = new Body({ mass: 1 });
        b2.addShape(s2);
        b2.position = new Vec3(-0.5, 0, 0);
        var actual = np.convexConvex(s1, s2, b1.position, b2.position, new Quaternion(), new Quaternion(), b1, b2, undefined, undefined, false);
        expect(actual).toEqual(true);
        expect(np.result.length).toEqual(4);
    });
    it('should return true if convexConvex does touch X (tri)', function () {
        var mc = mockCube();
        var mc2 = mockCube();
        var world = new World();
        var np = new Narrowphase(world);
        var s1 = new ConvexPolyhedron(mc[0], mc[2]);
        var s2 = new ConvexPolyhedron(mc2[0], mc2[2]);
        var b1 = new Body({ mass: 1 });
        b1.addShape(s1);
        b1.position = new Vec3(0.5, 0, 0);
        var b2 = new Body({ mass: 1 });
        b2.addShape(s2);
        b2.position = new Vec3(-0.5, 0, 0);
        var actual = np.convexConvex(s1, s2, b1.position, b2.position, new Quaternion(), new Quaternion(), b1, b2, undefined, undefined, false);
        expect(actual).toEqual(true);
        expect(np.result.length).toEqual(3);
    });
    it('should return true if convexConvex does touch Y (quad)', function () {
        var s1 = mockBoxHull(1);
        var s2 = mockBoxHull(1);
        var world = new World();
        var np = new Narrowphase(world);
        var b1 = new Body({ mass: 1 });
        b1.addShape(s1);
        b1.position = new Vec3(0, 0.5, 0);
        var b2 = new Body({ mass: 1 });
        b2.addShape(s2);
        b2.position = new Vec3(0, -0.5, 0);
        var actual = np.convexConvex(s1, s2, b1.position, b2.position, new Quaternion(), new Quaternion(), b1, b2, undefined, undefined, false);
        expect(actual).toEqual(true);
        expect(np.result.length).toEqual(4);
    });
    it('should return true if convexConvex does touch Y (tri)', function () {
        var mc = mockCube();
        var mc2 = mockCube();
        var world = new World();
        var np = new Narrowphase(world);
        var s1 = new ConvexPolyhedron(mc[0], mc[2]);
        var s2 = new ConvexPolyhedron(mc2[0], mc2[2]);
        var b1 = new Body({ mass: 1 });
        b1.addShape(s1);
        b1.position = new Vec3(0, 0.5, 0);
        var b2 = new Body({ mass: 1 });
        b2.addShape(s2);
        b2.position = new Vec3(0, -0.5, 0);
        var actual = np.convexConvex(s1, s2, b1.position, b2.position, new Quaternion(), new Quaternion(), b1, b2, undefined, undefined, false);
        expect(actual).toEqual(true);
        expect(np.result.length).toEqual(3);
    });
    it('should return true if convexConvex does touch Z (quad)', function () {
        var s1 = mockBoxHull(1);
        var s2 = mockBoxHull(1);
        var world = new World();
        var np = new Narrowphase(world);
        var b1 = new Body({ mass: 1 });
        b1.addShape(s1);
        b1.position = new Vec3(0, 0, 0.5);
        var b2 = new Body({ mass: 1 });
        b2.addShape(s2);
        b2.position = new Vec3(0, 0, -0.5);
        var actual = np.convexConvex(s1, s2, b1.position, b2.position, new Quaternion(), new Quaternion(), b1, b2, undefined, undefined, false);
        expect(actual).toEqual(true);
        expect(np.result.length).toEqual(4);
    });
    it('should return true if convexConvex does touch Z (tri)', function () {
        var mc = mockCube();
        var mc2 = mockCube();
        var world = new World();
        var np = new Narrowphase(world);
        var s1 = new ConvexPolyhedron(mc[0], mc[2]);
        var s2 = new ConvexPolyhedron(mc2[0], mc2[2]);
        var b1 = new Body({ mass: 1 });
        b1.addShape(s1);
        b1.position = new Vec3(0, 0, 0.5);
        var b2 = new Body({ mass: 1 });
        b2.addShape(s2);
        b2.position = new Vec3(0, 0, -0.5);
        var actual = np.convexConvex(s1, s2, b1.position, b2.position, new Quaternion(), new Quaternion(), b1, b2, undefined, undefined, false);
        expect(actual).toEqual(true);
        expect(np.result.length).toEqual(3);
    });
});
