import { EventTarget } from '../utils/EventTarget';
import { Vec3 } from '../math/Vec3';
import { Material } from '../material/Material';
import { Quaternion } from '../math/Quaternion';
import { Shape } from '../shapes/Shape';
import { Mat3 } from '../math/Mat3';
import { AABB } from '../collision/AABB';
import { World } from '../world/World';
export declare class BodyOptions {
    mass: number;
    position: Vec3;
    quaternion: Quaternion;
    type: 1 | 2 | 4;
    material: Material;
}
export declare class Body extends EventTarget {
    static idCounter: number;
    static COLLIDE_EVENT_NAME: string;
    static DYNAMIC: number;
    static STATIC: number;
    static KINEMATIC: number;
    static AWAKE: number;
    static SLEEPY: number;
    static SLEEPING: number;
    goid: string;
    id: number;
    index: number;
    world: World;
    preStep: Function;
    postStep: Function;
    vlambda: Vec3;
    collisionFilterGroup: number;
    collisionFilterMask: number;
    collisionResponse: boolean;
    position: Vec3;
    previousPosition: Vec3;
    interpolatedPosition: Vec3;
    initPosition: Vec3;
    velocity: Vec3;
    initVelocity: Vec3;
    force: Vec3;
    mass: number;
    invMass: number;
    material: Material;
    linearDamping: number;
    type: number;
    allowSleep: boolean;
    sleepState: number;
    sleepSpeedLimit: number;
    sleepTimeLimit: number;
    timeLastSleepy: number;
    _wakeUpAfterNarrowphase: boolean;
    torque: Vec3;
    quaternion: Quaternion;
    initQuaternion: Quaternion;
    previousQuaternion: Quaternion;
    interpolatedQuaternion: Quaternion;
    angularVelocity: Vec3;
    initAngularVelocity: Vec3;
    shapes: Shape[];
    shapeOffsets: Vec3[];
    shapeOrientations: Quaternion[];
    inertia: Vec3;
    invInertia: Vec3;
    invInertiaWorld: Mat3;
    invMassSolve: number;
    invInertiaSolve: Vec3;
    invInertiaWorldSolve: Mat3;
    fixedRotation: boolean;
    angularDamping: number;
    linearFactor: Vec3;
    angularFactor: Vec3;
    aabb: AABB;
    aabbNeedsUpdate: boolean;
    boundingRadius: number;
    wlambda: Vec3;
    constructor(options?: BodyOptions | any);
    static wakeupEvent: {
        type: string;
    };
    static sleepyEvent: {
        type: string;
    };
    static sleepEvent: {
        type: string;
    };
    wakeUp(): void;
    sleep(): void;
    sleepTick(time: number): void;
    updateSolveMassProperties(): void;
    pointToLocalFrame(worldPoint: Vec3, result?: Vec3): Vec3;
    vectorToLocalFrame(worldVector: Vec3, result?: Vec3): Vec3;
    pointToWorldFrame(localPoint: Vec3, result?: Vec3): Vec3;
    vectorToWorldFrame(localVector: Vec3, result?: Vec3): Vec3;
    private tmpVec;
    private tmpQuat;
    addShape(shape: Shape, _offset?: Vec3, _orientation?: Quaternion): this;
    updateBoundingRadius(): void;
    private computeAABB_shapeAABB;
    computeAABB(): void;
    private uiw_m1;
    private uiw_m2;
    private uiw_m3;
    updateInertiaWorld(force?: boolean): void;
    private Body_applyForce_r;
    private Body_applyForce_rotForce;
    applyForce(force: Vec3, relativePoint: Vec3): void;
    private Body_applyLocalForce_worldForce;
    private Body_applyLocalForce_relativePointWorld;
    applyLocalForce(localForce: Vec3, localPoint: Vec3): void;
    private Body_applyImpulse_r;
    private Body_applyImpulse_velo;
    private Body_applyImpulse_rotVelo;
    applyImpulse(impulse: Vec3, relativePoint: Vec3): void;
    private Body_applyLocalImpulse_worldImpulse;
    private Body_applyLocalImpulse_relativePoint;
    applyLocalImpulse(localImpulse: Vec3, localPoint: Vec3): void;
    private Body_updateMassProperties_halfExtents;
    updateMassProperties(): void;
    getVelocityAtWorldPoint(worldPoint: Vec3, result: Vec3): Vec3;
    private invI_tau_dt;
    private w;
    private wq;
    integrate(dt: number, quatNormalize: boolean, quatNormalizeFast: boolean): void;
}
