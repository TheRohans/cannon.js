import { World } from './World';
import { Vec3Pool } from '../utils/Vec3Pool';
import { ContactMaterial } from '../material/ContactMaterial';
import { Shape } from '../shapes/Shape';
import { Body } from '../objects/Body';
import { Vec3 } from '../math/Vec3';
import { Quaternion } from '../math/Quaternion';
import { FrictionEquation } from '../equations/FrictionEquation';
export declare class Narrowphase {
    contactPointPool: any[];
    frictionEquationPool: FrictionEquation[];
    result: any[];
    frictionResult: any[];
    v3pool: Vec3Pool;
    world: World;
    currentContactMaterial: ContactMaterial;
    enableFrictionReduction: boolean;
    constructor(world: World);
    createContactEquation(bi: Body, bj: Body, si: Shape, sj: Shape, overrideShapeA: Shape, overrideShapeB: Shape): any;
    createFrictionEquationsFromContact(contactEquation: FrictionEquation, outArray: any[]): boolean;
    private averageNormal;
    private averageContactPointA;
    private averageContactPointB;
    createFrictionFromAverage(numContacts: number): void;
    private tmpVec1;
    private tmpVec2;
    private tmpQuat1;
    private tmpQuat2;
    getContacts(p1: Body[], p2: Body[], world: World, result: any[], oldcontacts: any[], frictionResult: any, frictionPool: any): void;
    boxBox(si: Shape, sj: Shape, xi: Vec3, xj: Vec3, qi: Quaternion, qj: Quaternion, bi: Body, bj: Body, rsi: Shape, rsj: Shape, justTest: boolean): boolean;
    boxConvex(si: Shape, sj: Shape, xi: Vec3, xj: Vec3, qi: Quaternion, qj: Quaternion, bi: Body, bj: Body, rsi: Shape, rsj: Shape, justTest: boolean): boolean;
    boxParticle(si: Shape, sj: Shape, xi: Vec3, xj: Vec3, qi: Quaternion, qj: Quaternion, bi: Body, bj: Body, rsi: Shape, rsj: Shape, justTest: boolean): boolean;
    sphereSphere(si: Shape, sj: Shape, xi: Vec3, xj: Vec3, qi: Quaternion, qj: Quaternion, bi: Body, bj: Body, rsi: Shape, rsj: Shape, justTest: boolean): boolean;
    private point_on_plane_to_sphere;
    private plane_to_sphere_ortho;
    spherePlane(si: Shape, sj: Shape, xi: Vec3, xj: Vec3, qi: Quaternion, qj: Quaternion, bi: Body, bj: Body, rsi: Shape, rsj: Shape, justTest: boolean): boolean;
    private pointInPolygon_edge;
    private pointInPolygon_edge_x_normal;
    private pointInPolygon_vtp;
    pointInPolygon(verts: Vec3[], normal: Vec3, p: Vec3): boolean;
    private box_to_sphere;
    private sphereBox_ns;
    private sphereBox_ns1;
    private sphereBox_ns2;
    private sphereBox_sides;
    private sphereBox_sphere_to_corner;
    private sphereBox_side_ns;
    private sphereBox_side_ns1;
    private sphereBox_side_ns2;
    sphereBox(si: Shape, sj: Shape, xi: Vec3, xj: Vec3, qi: Quaternion, qj: Quaternion, bi: Body, bj: Body, rsi: Shape, rsj: Shape, justTest: boolean): boolean;
    private convex_to_sphere;
    private sphereConvex_edge;
    private sphereConvex_edgeUnit;
    private sphereConvex_sphereToCorner;
    private sphereConvex_worldCorner;
    private sphereConvex_worldNormal;
    private sphereConvex_worldPoint;
    private sphereConvex_worldSpherePointClosestToPlane;
    private sphereConvex_penetrationVec;
    private sphereConvex_sphereToWorldPoint;
    sphereConvex(si: Shape, sj: Shape, xi: Vec3, xj: Vec3, qi: Quaternion, qj: Quaternion, bi: Body, bj: Body, rsi: Shape, rsj: Shape, justTest: boolean): boolean;
    private planeBox_normal;
    private plane_to_corner;
    planeBox(si: Shape, sj: Shape, xi: Vec3, xj: Vec3, qi: Quaternion, qj: Quaternion, bi: Body, bj: Body, rsi: Shape, rsj: Shape, justTest: boolean): boolean;
    private planeConvex_v;
    private planeConvex_normal;
    private planeConvex_relpos;
    private planeConvex_projected;
    planeConvex(si: Shape, sj: Shape, xi: Vec3, xj: Vec3, qi: Quaternion, qj: Quaternion, bi: Body, bj: Body, rsi: Shape, rsj: Shape, justTest: boolean): boolean;
    private convexConvex_sepAxis;
    private convexConvex_q;
    convexConvex(si: Shape, sj: Shape, xi: Vec3, xj: Vec3, qi: Quaternion, qj: Quaternion, bi: Body, bj: Body, rsi: Shape, rsj: Shape, justTest: boolean, faceListA?: any[], faceListB?: any[]): boolean;
    private particlePlane_normal;
    private particlePlane_relpos;
    private particlePlane_projected;
    planeParticle(si: Shape, sj: Shape, xi: Vec3, xj: Vec3, qi: Quaternion, qj: Quaternion, bi: Body, bj: Body, rsi: Shape, rsj: Shape, justTest: boolean): boolean;
    private particleSphere_normal;
    sphereParticle(si: Shape, sj: Shape, xi: Vec3, xj: Vec3, qi: Quaternion, qj: Quaternion, bi: Body, bj: Body, rsi: Shape, rsj: Shape, justTest: boolean): boolean;
    private cqj;
    private convexParticle_local;
    private convexParticle_normal;
    private convexParticle_penetratedFaceNormal;
    private convexParticle_vertexToParticle;
    private convexParticle_worldPenetrationVec;
    convexParticle(si: Shape, sj: Shape, xi: Vec3, xj: Vec3, qi: Quaternion, qj: Quaternion, bi: Body, bj: Body, rsi: Shape, rsj: Shape, justTest: boolean): boolean;
}
